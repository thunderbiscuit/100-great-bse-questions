{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"100 Great Bitcoin Stack Exchange Questions and their Answers","title":"Home"},{"location":"#100-great-bitcoin-stack-exchangequestions-and-their-answers","text":"","title":"100 Great Bitcoin Stack ExchangeQuestions and their Answers"},{"location":"cryptography/q0/","text":"Template","title":"Q71"},{"location":"cryptography/q0/#template","text":"","title":"Template"},{"location":"history/q91/","text":"Will there be 21 million bitcoins eventually? Every x blocks the mining reward is halved. Will the reward be halved forever such that we never quite reach 21 million bitcoins, or will we reach 21 million bitcoins at some point and will the reward cease to exist altogether? Original Question Answer Answered by: Pieter Wuille People say the total will be 21000000 BTC. ... however: The 1st 210000 blocks each allow creating 50 BTC. The 2nd 210000 blocks each allow creating 25 BTC. The 3rd 210000 blocks each allow creating 12.5 BTC. ... The 10th 210000 blocks each allow creating 0.09765625 BTC. The 11th 210000 blocks each allow creating 0.04882812 BTC, and not 0.048828125 BTC, because only 8 decimals of precision are supported. ... The 33rd 210000 blocks each allow creating 0.00000001 BTC. After that, the reward is 0. If you sum all these numbers together, you get 20999999.9769 BTC. ... however, either due to an oversight or intentionally, the coins created in the genesis block cannot be spent. This leaves us with 20999949.9769 BTC. ... however, due to an early problem in Bitcoin, fixed by BIP30, it was possible to create a coinbase transaction identical to a previous coinbase. This caused the coins created by that older coinbase to be irreversibly \"overwritten\". This happened in block 91842 (overwriting the coinbase of block 91812) and 91880 (overwriting the coinbase of block 91722). Each time, 50 BTC was lost. This leaves us with 20999849.9769 BTC. ... however, the protocol rules allow creating up to the amounts listed above. Due to various bugs and miners experimenting with code, some blocks claim less than allowed. Those coins can never be recovered. Block 124724 tried to intentionally claim 0.00000001 BTC less than allowed, but accidentally also failed to claim the fees, losing 0.01000001 BTC. Between block 162705 and block 169899, 193 blocks claimed less than allowed due to a bug, resulting in a total loss of 9.66184623 BTC. Between block 180324 and block 249185, another 836 blocks claimed less than allowed, resulting in a total loss of 0.52584193 BTC. Block 501726 had no transaction outputs (except a 0-value commitment), losing the entire 12.5 BTC subsidy. Block 526591 didn't claim half of the block reward, losing 6.25 BTC. This leaves us with 20999821.02921183 BTC. ... however, since recently there is a concept of provably unspendable coins. Coins can be sent to an \"address\" which provably burns them (using OP_RETURN). Bitcoin Core tracks these and removes them from its database, so they are easily accounted for. At least 3.71612692 BTC were burned this way. This leaves us with 20999817.31308491 BTC (taking everything up to block 528333 into account) ... However, various wallets have been lost or stolen, transactions have been sent to the wrong address, people forgot they owned bitcoin. The totals of this may well be millions. People have tried to tally known losses up here . This leaves us with: ??? BTC.","title":"Q91"},{"location":"history/q91/#will-there-be-21-million-bitcoins-eventually","text":"Every x blocks the mining reward is halved. Will the reward be halved forever such that we never quite reach 21 million bitcoins, or will we reach 21 million bitcoins at some point and will the reward cease to exist altogether? Original Question","title":"Will there be 21 million bitcoins eventually?"},{"location":"history/q91/#answer","text":"Answered by: Pieter Wuille People say the total will be 21000000 BTC. ... however: The 1st 210000 blocks each allow creating 50 BTC. The 2nd 210000 blocks each allow creating 25 BTC. The 3rd 210000 blocks each allow creating 12.5 BTC. ... The 10th 210000 blocks each allow creating 0.09765625 BTC. The 11th 210000 blocks each allow creating 0.04882812 BTC, and not 0.048828125 BTC, because only 8 decimals of precision are supported. ... The 33rd 210000 blocks each allow creating 0.00000001 BTC. After that, the reward is 0. If you sum all these numbers together, you get 20999999.9769 BTC. ... however, either due to an oversight or intentionally, the coins created in the genesis block cannot be spent. This leaves us with 20999949.9769 BTC. ... however, due to an early problem in Bitcoin, fixed by BIP30, it was possible to create a coinbase transaction identical to a previous coinbase. This caused the coins created by that older coinbase to be irreversibly \"overwritten\". This happened in block 91842 (overwriting the coinbase of block 91812) and 91880 (overwriting the coinbase of block 91722). Each time, 50 BTC was lost. This leaves us with 20999849.9769 BTC. ... however, the protocol rules allow creating up to the amounts listed above. Due to various bugs and miners experimenting with code, some blocks claim less than allowed. Those coins can never be recovered. Block 124724 tried to intentionally claim 0.00000001 BTC less than allowed, but accidentally also failed to claim the fees, losing 0.01000001 BTC. Between block 162705 and block 169899, 193 blocks claimed less than allowed due to a bug, resulting in a total loss of 9.66184623 BTC. Between block 180324 and block 249185, another 836 blocks claimed less than allowed, resulting in a total loss of 0.52584193 BTC. Block 501726 had no transaction outputs (except a 0-value commitment), losing the entire 12.5 BTC subsidy. Block 526591 didn't claim half of the block reward, losing 6.25 BTC. This leaves us with 20999821.02921183 BTC. ... however, since recently there is a concept of provably unspendable coins. Coins can be sent to an \"address\" which provably burns them (using OP_RETURN). Bitcoin Core tracks these and removes them from its database, so they are easily accounted for. At least 3.71612692 BTC were burned this way. This leaves us with 20999817.31308491 BTC (taking everything up to block 528333 into account) ... However, various wallets have been lost or stolen, transactions have been sent to the wrong address, people forgot they owned bitcoin. The totals of this may well be millions. People have tried to tally known losses up here . This leaves us with: ??? BTC.","title":"Answer"},{"location":"mining/q0/","text":"Template","title":"Q61"},{"location":"mining/q0/#template","text":"","title":"Template"},{"location":"nodes-p2p/q41/","text":"What is the minRelayTxFee? What is the minRelayTxFee ? What is it used for, what's the default value and how does the value change? Question Link Answer Answered by: Murch The minRelayTxFee specifies a feerate acting as a lower bound for a node's mempool. A node will not admit unconfirmed transactions below that feerate to its mempool and thus will not relay them to its peers. The minRelayTxFee is a configuration setting and can be specified by each node operator independently. The value only impacts unconfirmed transactions, transactions included in a block are processed even when they do not meet the minRelayTxFee . Note that contrary to its name's implication, the minRelayTxFee is not an absolute fee, but a feerate. The current default value for the minRelayTxFee in Bitcoin Core is 1000 satoshi/kB (= 1 sat/B). A node operator may specify a different value via the startup parameter -minrelaytxfee=<amt> or the configuration parameter minrelaytxfee=<amt> which takes an <amt> in [BTC/kB]. The minRelayTxFee also serves as the basis to calculate the minimum cost increments for replacement transactions per BIP-125 (Opt-in RBF). It was also previously used to calculate the dust limit which has since been decoupled into a separate feerate called DUST_RELAY_TX_FEE with a default value of 3000 sat/kvB (H/T Darius ). minRelayTxFee should not be confused with: minTxFee , which is a wallet configuration setting that sets a lower bound when creating new transactions mempoolminfee , which is an independent lower bound for mempool acceptance that dynamically increases when the mempool limit is exceeded Bitcoin Core 0.13.0 introduced a new, optional feefilter P2P message, which will tell neighboring nodes not to send transactions below the filter's feerate. Older nodes do not communicate their minimum feerate, but rather just drop incoming transactions that doesn't pass it. You may retrieve the current values for your node by calling the getmempoolinfo RPC.","title":"Q41"},{"location":"nodes-p2p/q41/#what-is-the-minrelaytxfee","text":"What is the minRelayTxFee ? What is it used for, what's the default value and how does the value change? Question Link","title":"What is the minRelayTxFee?"},{"location":"nodes-p2p/q41/#answer","text":"Answered by: Murch The minRelayTxFee specifies a feerate acting as a lower bound for a node's mempool. A node will not admit unconfirmed transactions below that feerate to its mempool and thus will not relay them to its peers. The minRelayTxFee is a configuration setting and can be specified by each node operator independently. The value only impacts unconfirmed transactions, transactions included in a block are processed even when they do not meet the minRelayTxFee . Note that contrary to its name's implication, the minRelayTxFee is not an absolute fee, but a feerate. The current default value for the minRelayTxFee in Bitcoin Core is 1000 satoshi/kB (= 1 sat/B). A node operator may specify a different value via the startup parameter -minrelaytxfee=<amt> or the configuration parameter minrelaytxfee=<amt> which takes an <amt> in [BTC/kB]. The minRelayTxFee also serves as the basis to calculate the minimum cost increments for replacement transactions per BIP-125 (Opt-in RBF). It was also previously used to calculate the dust limit which has since been decoupled into a separate feerate called DUST_RELAY_TX_FEE with a default value of 3000 sat/kvB (H/T Darius ). minRelayTxFee should not be confused with: minTxFee , which is a wallet configuration setting that sets a lower bound when creating new transactions mempoolminfee , which is an independent lower bound for mempool acceptance that dynamically increases when the mempool limit is exceeded Bitcoin Core 0.13.0 introduced a new, optional feefilter P2P message, which will tell neighboring nodes not to send transactions below the filter's feerate. Older nodes do not communicate their minimum feerate, but rather just drop incoming transactions that doesn't pass it. You may retrieve the current values for your node by calling the getmempoolinfo RPC.","title":"Answer"},{"location":"transactions/q1/","text":"How do virtual size, stripped size and raw size compare between legacy address formats and native segwit? This answer states that SegWit doesn't reduce transaction size. If this is true, why is it cheaper to send a SegWit transaction? Answer Let's compare a 2-input and 2-output transaction for single-sig output types. I'll refer to the byte length of the transaction as \"raw size\" , the transaction without its witness data as \"stripped size\", and the size-equivalent when accounting for the witness discount as \"virtual size\". Table showing the detailed data P2PKH \u2013 Pay to Public Key Hash has no witness data, so raw size is equal to stripped size is equal to virtual size. A P2PKH transaction with two inputs and two outputs has 374 bytes (= 374 vbytes). P2SH-P2WPKH \u2013 Pay to Script Hash-wrapped Pay to Witness Public Key Hash (aka \"wrapped segwit\") locks funds to a P2SH output, but the input's redeemscript contains a witness program that redirects the evaluation to the witness stack. The content of the witness stack is the same as a P2PKH scriptSig . A P2SH-P2WPKH transaction with two inputs and two outputs has a raw size of 420 bytes, a stripped size (removing witness data) of 202 bytes, and a virtual size of 256.5 vbytes. P2WPKH \u2013 Pay to Witness Public Key Hash (aka single-sig v0 native segwit) does not need the P2SH indirection, but directly resolves a witness program. It has the same witness stack as a P2SH-P2WPKH input. A P2WPKH transaction with two inputs and two outputs has a raw size of 372 bytes, a stripped size of 154 bytes and a virtual size of 208.5 vbytes. P2TR \u2013 Pay to Taproot (v1 native segwit (keypath-spend)) also directly resolves a witness program. Since the witness program already contains a public key instead of a pubkey hash, the witness stack is smaller by the public key, but the output script is larger. A P2TR transaction with two inputs and two outputs has a raw size of 312 bytes, a stripped size of 178 bytes, and a virtual size of 211.5 vbytes. The raw size corresponds to the data footprint of the transaction on disk or the bandwidth cost to transmit it. We see that P2SH-P2WPKH is actually the biggest in raw size by a margin. P2WPKH and P2PKH are very close to each other in raw size with the legacy format P2PKH being slightly smaller in input size, but slightly bigger in output size. P2TR has the smallest data footprint. The virtual size corresponds to the blockweight which determines the fees and how many transactions can fit in a block. After applying the weighing that the witness is subject to, P2WPKH has the smallest weight, closely followed by P2TR, followed by P2SH-P2WPKH and the legacy format P2PKH counts as the heaviest. Size calculations Transaction headers list the transaction version (4 B), the count of inputs (VarInt, usually 1 B, but up to 9 B), the count of outputs (varInt, usually 1 B, but up to 9 B), and the locktime (4 B). For segwit transactions, we add a witness marker (1 WU) and a witness flag (1 WU) that pertain to the whole transaction. Every input must indicate the UXTO it's spending per an outpoint (txid+vout = 32+4 B), have a sequence value (4 B), and have an input script ( scriptSig ). For non-segwit output types, the scriptSig contains script arguments and/or a redeemscript to satisfy the output script ( scriptPubKey ). For wrapped segwit inputs, the scriptSig consists of a redeemscript that contains a witness program which redirects to the Witness Stack as the final script . For native segwit outputs, the scriptSig is empty which is indicated by a scriptSig length of 0. Per the segwit rules this is interpreted as a validation redirection to the Witness Stack . Note that if a transaction has at least one segwit input, there must be a Witness Stack for every input, with non-segwit inputs having a length-zero Witness Stack (i.e. just one byte to indicate the length of 0). Outputs consist of an amount of satoshis (8 B) and an output script ( scriptPubKey ). Outputs don't have witness data. P2PKH TxHeader: 10 B = 40 WU Input\u00b9: 148 B = 592 WU Output: 34 B = 136 WU For legacy formats, the raw size, stripped size and virtual size are all equal because they do not have witness data. Tx with 2 inputs and 2 outputs: raw = stripped = vsize = 10\u202fB + 2\u00d7148\u202fB + 2\u00d734\u202fB = 374 B = 374 vB weight = 4\u00d7374\u202fvB = 1496 WU P2SH-P2WPKH TxHeader: 10 B + 2 WU = 10.5 vB = 42 WU Input\u00b2: 64 B + 108 WU = 91 vB = 364 WU Output: 32 vB = 128 WU Tx with 2 inputs and 2 outputs: raw = 12 B + 2\u00d7(64 B + 108 B) + 2\u00d732 B = 420 B stripped = 1 0 B + 2\u00d764 B + 2+32 B = 202 B weight = 42 WU + 2\u00d7(4\u00d764 vB + 108 WU) + 2\u00d7128 WU = 1026 WU = 256.5 vB P2WPKH TxHeader: 10 B + 2 WU = 10.5 vB = 42 WU Input\u00b3: 41 vB + 108 WU = 68 vB = 272 WU Output: 31 vB = 124 WU Tx with 2 inputs and 2 outputs: raw = 12 B + 2\u00d7(41 B + 108 B) + 2\u00d731 B = 372 B stripped = 10 B + 2\u00d741 B + 2\u00d731 B = 154 B weight = 42 WU + 2\u00d7(4\u00d741 vB + 108 WU) + 2\u00d7124 WU = 834 WU = 208.5 vB P2TR TxHeader: 10 B + 2 WU = 10.5 vB = 42 WU Input\u2074: 41 vB + 66 WU = 57.5 vB = 230 WU Output: 43 vB = 172 WU Tx with 2 inputs and 2 outputs: raw = 12 B + 2\u00d7(41 B + 66 B) + 2\u00d743 B = 312 B stripped = 10 B + 2\u00d741 B + 2\u00d743 B = 178 B weight = 42 WU + 2\u00d7(4\u00d741 vB + 66 WU) + 2\u00d7178 WU = 846 WU = 211.5 vB Meta Original question: Link Answer provided by: Murch","title":"Q1"},{"location":"transactions/q1/#how-do-virtual-size-stripped-size-and-raw-size-compare-between-legacy-address-formats-and-native-segwit","text":"This answer states that SegWit doesn't reduce transaction size. If this is true, why is it cheaper to send a SegWit transaction?","title":"How do virtual size, stripped size and raw size compare between legacy address formats and native segwit?"},{"location":"transactions/q1/#answer","text":"Let's compare a 2-input and 2-output transaction for single-sig output types. I'll refer to the byte length of the transaction as \"raw size\" , the transaction without its witness data as \"stripped size\", and the size-equivalent when accounting for the witness discount as \"virtual size\". Table showing the detailed data P2PKH \u2013 Pay to Public Key Hash has no witness data, so raw size is equal to stripped size is equal to virtual size. A P2PKH transaction with two inputs and two outputs has 374 bytes (= 374 vbytes). P2SH-P2WPKH \u2013 Pay to Script Hash-wrapped Pay to Witness Public Key Hash (aka \"wrapped segwit\") locks funds to a P2SH output, but the input's redeemscript contains a witness program that redirects the evaluation to the witness stack. The content of the witness stack is the same as a P2PKH scriptSig . A P2SH-P2WPKH transaction with two inputs and two outputs has a raw size of 420 bytes, a stripped size (removing witness data) of 202 bytes, and a virtual size of 256.5 vbytes. P2WPKH \u2013 Pay to Witness Public Key Hash (aka single-sig v0 native segwit) does not need the P2SH indirection, but directly resolves a witness program. It has the same witness stack as a P2SH-P2WPKH input. A P2WPKH transaction with two inputs and two outputs has a raw size of 372 bytes, a stripped size of 154 bytes and a virtual size of 208.5 vbytes. P2TR \u2013 Pay to Taproot (v1 native segwit (keypath-spend)) also directly resolves a witness program. Since the witness program already contains a public key instead of a pubkey hash, the witness stack is smaller by the public key, but the output script is larger. A P2TR transaction with two inputs and two outputs has a raw size of 312 bytes, a stripped size of 178 bytes, and a virtual size of 211.5 vbytes. The raw size corresponds to the data footprint of the transaction on disk or the bandwidth cost to transmit it. We see that P2SH-P2WPKH is actually the biggest in raw size by a margin. P2WPKH and P2PKH are very close to each other in raw size with the legacy format P2PKH being slightly smaller in input size, but slightly bigger in output size. P2TR has the smallest data footprint. The virtual size corresponds to the blockweight which determines the fees and how many transactions can fit in a block. After applying the weighing that the witness is subject to, P2WPKH has the smallest weight, closely followed by P2TR, followed by P2SH-P2WPKH and the legacy format P2PKH counts as the heaviest.","title":"Answer"},{"location":"transactions/q1/#size-calculations","text":"Transaction headers list the transaction version (4 B), the count of inputs (VarInt, usually 1 B, but up to 9 B), the count of outputs (varInt, usually 1 B, but up to 9 B), and the locktime (4 B). For segwit transactions, we add a witness marker (1 WU) and a witness flag (1 WU) that pertain to the whole transaction. Every input must indicate the UXTO it's spending per an outpoint (txid+vout = 32+4 B), have a sequence value (4 B), and have an input script ( scriptSig ). For non-segwit output types, the scriptSig contains script arguments and/or a redeemscript to satisfy the output script ( scriptPubKey ). For wrapped segwit inputs, the scriptSig consists of a redeemscript that contains a witness program which redirects to the Witness Stack as the final script . For native segwit outputs, the scriptSig is empty which is indicated by a scriptSig length of 0. Per the segwit rules this is interpreted as a validation redirection to the Witness Stack . Note that if a transaction has at least one segwit input, there must be a Witness Stack for every input, with non-segwit inputs having a length-zero Witness Stack (i.e. just one byte to indicate the length of 0). Outputs consist of an amount of satoshis (8 B) and an output script ( scriptPubKey ). Outputs don't have witness data.","title":"Size calculations"},{"location":"transactions/q1/#p2pkh","text":"TxHeader: 10 B = 40 WU Input\u00b9: 148 B = 592 WU Output: 34 B = 136 WU For legacy formats, the raw size, stripped size and virtual size are all equal because they do not have witness data. Tx with 2 inputs and 2 outputs: raw = stripped = vsize = 10\u202fB + 2\u00d7148\u202fB + 2\u00d734\u202fB = 374 B = 374 vB weight = 4\u00d7374\u202fvB = 1496 WU","title":"P2PKH"},{"location":"transactions/q1/#p2sh-p2wpkh","text":"TxHeader: 10 B + 2 WU = 10.5 vB = 42 WU Input\u00b2: 64 B + 108 WU = 91 vB = 364 WU Output: 32 vB = 128 WU Tx with 2 inputs and 2 outputs: raw = 12 B + 2\u00d7(64 B + 108 B) + 2\u00d732 B = 420 B stripped = 1 0 B + 2\u00d764 B + 2+32 B = 202 B weight = 42 WU + 2\u00d7(4\u00d764 vB + 108 WU) + 2\u00d7128 WU = 1026 WU = 256.5 vB","title":"P2SH-P2WPKH"},{"location":"transactions/q1/#p2wpkh","text":"TxHeader: 10 B + 2 WU = 10.5 vB = 42 WU Input\u00b3: 41 vB + 108 WU = 68 vB = 272 WU Output: 31 vB = 124 WU Tx with 2 inputs and 2 outputs: raw = 12 B + 2\u00d7(41 B + 108 B) + 2\u00d731 B = 372 B stripped = 10 B + 2\u00d741 B + 2\u00d731 B = 154 B weight = 42 WU + 2\u00d7(4\u00d741 vB + 108 WU) + 2\u00d7124 WU = 834 WU = 208.5 vB","title":"P2WPKH"},{"location":"transactions/q1/#p2tr","text":"TxHeader: 10 B + 2 WU = 10.5 vB = 42 WU Input\u2074: 41 vB + 66 WU = 57.5 vB = 230 WU Output: 43 vB = 172 WU Tx with 2 inputs and 2 outputs: raw = 12 B + 2\u00d7(41 B + 66 B) + 2\u00d743 B = 312 B stripped = 10 B + 2\u00d741 B + 2\u00d743 B = 178 B weight = 42 WU + 2\u00d7(4\u00d741 vB + 66 WU) + 2\u00d7178 WU = 846 WU = 211.5 vB","title":"P2TR"},{"location":"transactions/q1/#meta","text":"Original question: Link Answer provided by: Murch","title":"Meta"},{"location":"wallets/q21/","text":"BIP32 recommends a 256 bit seed. Why do most Bitcoin wallets only use a 128 bit seed? According to BIP32's \"Master key generation\" section, \"256 bits is advised\". See BIP32 Why did BIP32 consider 256 bits to be the recommended seed size, and why did the authors of so many Bitcoin wallet implementations consider 256 bits unnecessary? Question Link Answer Answered by: Pieter Wuille The reasons for the 3 numbers: Bitcoin uses 256-bit ECDSA signatures. These require in the order of 2128 steps to find a private key from the public key is known. This is Bitcoin's security level: we aim to always require an attacker to perform 2128 steps. If the seed has less than 128 bits of entropy, this inevitably leads to a faster algorithm, where an attacker can simply iterate through all possible seeds in less than 2128 steps. Because of that, BIP32 requires at least 128 bits of entropy. When the seed has less than 256 bits of entropy (but more than 128), the resulting keys will also have less than 256 bits of entropy. As elliptic curve cryptography uses keys with a full 256 bits (despite there being a faster attacker than breaks it in 2128 steps), BIP32 also recommends 256 bits of entropy. The combination of private key and chaincode (the \"extended private key\") in BIP32 are 512 bits in size. Because of that, using a seed with more entropy than 512 bits cannot possibly increase security more - it's just information that gets thrown away. Because of that BIP32 limits the seed to at most 512 bits of entropy. Comment 1 (OP): Thanks for your answer, Pieter. I'm not quite clear though: As you say, both public keys (compressed representation EC points) and private keys (scalars) are each represented with 256 bits, but they both have an effective bit strength of just 128 bits. Therefore why is there any advantage at all in generating scalar keys from a seed that has any more than 128 bits of entropy? The only reason I can think of is that bit strength is reduced a little when the seed is hashed to derive subkeys, but that would explain a recommendation for a seed of e.g. 140 bits rather than of a full 256 bits. Comment 2 (Pieter): Well, being able to break an EC key with just 2^128 steps is somewhat theoretical. In practice, these algorithms have significant memory/cpu tradeoffs, and in practice would still be much slower than a straight 2^128 exhaustive search on keys with just 128 bits of entropy. I guess the answer is defense in depth: less than 128 bits of entropy definitely hurts security. Less than 256 bits may hurt. More than 512 bits can't help.","title":"Q21"},{"location":"wallets/q21/#bip32-recommends-a-256-bit-seed-why-do-most-bitcoin-wallets-only-use-a-128-bit-seed","text":"According to BIP32's \"Master key generation\" section, \"256 bits is advised\". See BIP32 Why did BIP32 consider 256 bits to be the recommended seed size, and why did the authors of so many Bitcoin wallet implementations consider 256 bits unnecessary? Question Link","title":"BIP32 recommends a 256 bit seed. Why do most Bitcoin wallets only use a 128 bit seed?"},{"location":"wallets/q21/#answer","text":"Answered by: Pieter Wuille The reasons for the 3 numbers: Bitcoin uses 256-bit ECDSA signatures. These require in the order of 2128 steps to find a private key from the public key is known. This is Bitcoin's security level: we aim to always require an attacker to perform 2128 steps. If the seed has less than 128 bits of entropy, this inevitably leads to a faster algorithm, where an attacker can simply iterate through all possible seeds in less than 2128 steps. Because of that, BIP32 requires at least 128 bits of entropy. When the seed has less than 256 bits of entropy (but more than 128), the resulting keys will also have less than 256 bits of entropy. As elliptic curve cryptography uses keys with a full 256 bits (despite there being a faster attacker than breaks it in 2128 steps), BIP32 also recommends 256 bits of entropy. The combination of private key and chaincode (the \"extended private key\") in BIP32 are 512 bits in size. Because of that, using a seed with more entropy than 512 bits cannot possibly increase security more - it's just information that gets thrown away. Because of that BIP32 limits the seed to at most 512 bits of entropy. Comment 1 (OP): Thanks for your answer, Pieter. I'm not quite clear though: As you say, both public keys (compressed representation EC points) and private keys (scalars) are each represented with 256 bits, but they both have an effective bit strength of just 128 bits. Therefore why is there any advantage at all in generating scalar keys from a seed that has any more than 128 bits of entropy? The only reason I can think of is that bit strength is reduced a little when the seed is hashed to derive subkeys, but that would explain a recommendation for a seed of e.g. 140 bits rather than of a full 256 bits. Comment 2 (Pieter): Well, being able to break an EC key with just 2^128 steps is somewhat theoretical. In practice, these algorithms have significant memory/cpu tradeoffs, and in practice would still be much slower than a straight 2^128 exhaustive search on keys with just 128 bits of entropy. I guess the answer is defense in depth: less than 128 bits of entropy definitely hurts security. Less than 256 bits may hurt. More than 512 bits can't help.","title":"Answer"},{"location":"wallets/q22/","text":"What are the potential attacks against ECDSA that would be possible if we used raw public keys as addresses? According to this answer about why addresses are hashes rather than public keys there are potential attacks that are possible if you have the public key rather than the address, what are these attacks? If one was writing a cryptocurrency would you advise against the addresses being the public key encoded in base58 with a checksum on the end? why? Question Link Answer Answered by: Pieter Wuille The theory It is assumed that in order to forge an ECDSA signature you need to compute the private key for a given public key first (this operation is known as the \"discrete logarithm\" (DL), and its hardness is the basis for ECDSA's security). In order to do so, you must actually have the public key. Once you have the public key, it is assumed that you need at least 2128 operations to compute its private key. That's an enormous amount (if every computer in the world could do one relevant operation per clock cycle it would take over 100 million years; in reality it'd be orders of magnitude more than that). However, that is assuming that there are no fundamental breakthroughs in algorithms to compute the discrete logarithm, or quantum computers. A sufficiently powerful quantum computer (not anything anywhere near what already exists) may be able to do this computation much faster. By using an address that contains a hash of the public key rather than the public key directly, the actual public key is not revealed to the world until the output is spent by its owner. Barring any (spectacular) vulnerabilities found in the used hash functions (SHA256 and RIPEMD160), even a quantum computer cannot trivially find a public key from a hash function. However, the 160-bit hashes used are still considered relatively weak in this case (280 operations on a sufficiently powerful quantum computer). In short: the argument is that by using public key hashes, the ability for someone with a DL break, or a hypothetical quantum computer, to steal coins is made harder. In practice What I write in this section is my own opinion, and presumably not everyone agrees with it. I believe this (often repeated) advantage of hashed public keys is marginal at best, and a false sense of security at worst. There are several reasons for this: The argument only applies until the output is (attempted to be) spent. Once someone tries to spend a pay-to-pubkey-hash output, they reveal the full public key. With minor cooperation from miners, the original transaction could be delayed temporarily to give the hypothetical quantum computing attacker time to find the private key and steal the coins. Address reuse was, and still is, very common, and apparently hard to avoid. Whenever addresses are reused, their public key is revealed on the first spend, making all future ones vulnerable still. Almost all interesting things that people do with Bitcoin (including multisig, 2FA, escrows, payment channels, BIP32 accounts, ...) involve sharing public keys with other parties. It's an illusion to think that in such a world any security is gained by using public key hashes - as public keys are revealed all the time still, often without people even knowing about it. Even if you restrict yourself to carefully not rely on any of these techniques and keep all your public keys actually secret until spent, there are over 5 million BTC (my own research ) stored with publicly known public keys. I cannot imagine that BTC retains any value if those become practically vulnerable to theft (or even just credibly believed to be vulnerable). This doesn't mean we have a problem. Sufficiently powerful quantum computers are far away - if they're feasible at all for the enormous number of q-bits needed to solve these problems. This gives us time to slowly migrate to schemes that are actually quantum resistant (by not using ECDSA or similar cryptography at all). This is not yet done, as currently existing quantum-resistant schemes come with very large keys and signatures, and various other caveats. This makes them very unappealing fow now, but research on them is proceeding rapidly, and, if needed, they exist. Should you use public key addresses? If one was writing a cryptocurrency would you advise against the addresses being the public key encoded in base58 with a checksum on the end? why? Advice on other cryptocurrencies is off-topic here, but the Taproot proposal for Bitcoin would effectively do this. Its outputs (and thus addresses) contain a full public key, because it comes with numerous advantages (it's smaller, cheaper, and makes a number of more advanced protocols on top a lot easier). The Bech32 address format is used for these types of outputs, which has a number of advantages over Base58 (easier to transliterate/compare, stronger error detection, more extensible, smaller QR codes, ...). Disclaimer: I'm a co-author of both the Taproot proposal and the Bech32 standard. TL;DR: Public keys should be public.","title":"Q22"},{"location":"wallets/q22/#what-are-the-potential-attacks-against-ecdsa-that-would-be-possible-if-we-used-raw-public-keys-as-addresses","text":"According to this answer about why addresses are hashes rather than public keys there are potential attacks that are possible if you have the public key rather than the address, what are these attacks? If one was writing a cryptocurrency would you advise against the addresses being the public key encoded in base58 with a checksum on the end? why? Question Link","title":"What are the potential attacks against ECDSA that would be possible if we used raw public keys as addresses?"},{"location":"wallets/q22/#answer","text":"Answered by: Pieter Wuille The theory It is assumed that in order to forge an ECDSA signature you need to compute the private key for a given public key first (this operation is known as the \"discrete logarithm\" (DL), and its hardness is the basis for ECDSA's security). In order to do so, you must actually have the public key. Once you have the public key, it is assumed that you need at least 2128 operations to compute its private key. That's an enormous amount (if every computer in the world could do one relevant operation per clock cycle it would take over 100 million years; in reality it'd be orders of magnitude more than that). However, that is assuming that there are no fundamental breakthroughs in algorithms to compute the discrete logarithm, or quantum computers. A sufficiently powerful quantum computer (not anything anywhere near what already exists) may be able to do this computation much faster. By using an address that contains a hash of the public key rather than the public key directly, the actual public key is not revealed to the world until the output is spent by its owner. Barring any (spectacular) vulnerabilities found in the used hash functions (SHA256 and RIPEMD160), even a quantum computer cannot trivially find a public key from a hash function. However, the 160-bit hashes used are still considered relatively weak in this case (280 operations on a sufficiently powerful quantum computer). In short: the argument is that by using public key hashes, the ability for someone with a DL break, or a hypothetical quantum computer, to steal coins is made harder. In practice What I write in this section is my own opinion, and presumably not everyone agrees with it. I believe this (often repeated) advantage of hashed public keys is marginal at best, and a false sense of security at worst. There are several reasons for this: The argument only applies until the output is (attempted to be) spent. Once someone tries to spend a pay-to-pubkey-hash output, they reveal the full public key. With minor cooperation from miners, the original transaction could be delayed temporarily to give the hypothetical quantum computing attacker time to find the private key and steal the coins. Address reuse was, and still is, very common, and apparently hard to avoid. Whenever addresses are reused, their public key is revealed on the first spend, making all future ones vulnerable still. Almost all interesting things that people do with Bitcoin (including multisig, 2FA, escrows, payment channels, BIP32 accounts, ...) involve sharing public keys with other parties. It's an illusion to think that in such a world any security is gained by using public key hashes - as public keys are revealed all the time still, often without people even knowing about it. Even if you restrict yourself to carefully not rely on any of these techniques and keep all your public keys actually secret until spent, there are over 5 million BTC (my own research ) stored with publicly known public keys. I cannot imagine that BTC retains any value if those become practically vulnerable to theft (or even just credibly believed to be vulnerable). This doesn't mean we have a problem. Sufficiently powerful quantum computers are far away - if they're feasible at all for the enormous number of q-bits needed to solve these problems. This gives us time to slowly migrate to schemes that are actually quantum resistant (by not using ECDSA or similar cryptography at all). This is not yet done, as currently existing quantum-resistant schemes come with very large keys and signatures, and various other caveats. This makes them very unappealing fow now, but research on them is proceeding rapidly, and, if needed, they exist. Should you use public key addresses? If one was writing a cryptocurrency would you advise against the addresses being the public key encoded in base58 with a checksum on the end? why? Advice on other cryptocurrencies is off-topic here, but the Taproot proposal for Bitcoin would effectively do this. Its outputs (and thus addresses) contain a full public key, because it comes with numerous advantages (it's smaller, cheaper, and makes a number of more advanced protocols on top a lot easier). The Bech32 address format is used for these types of outputs, which has a number of advantages over Base58 (easier to transliterate/compare, stronger error detection, more extensible, smaller QR codes, ...). Disclaimer: I'm a co-author of both the Taproot proposal and the Bech32 standard. TL;DR: Public keys should be public.","title":"Answer"}]}